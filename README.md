# wanted_pre_onboarding

![](https://user-images.githubusercontent.com/79869058/152924513-2842ca76-b1aa-46a8-ac50-2baece1dcea6.gif)

## 1. Toggle

### 구현방법
React Hooks로 토글버튼의 on/off 상태를 값으로 가지면서 이 값을 변화시키는 함수를 이벤트핸들러에 추가하여 요소를 클릭할때마다 상태에 변화를 준다. 그리고 그 상태가 변화함에 따라 className을 변경하여 CSS의 변화를 주면 된다. 

### Error Handling Log
토글버튼의 기능은 어렵지않아 쉽게 구현할 수 있었다. 하지만 예기치 못한곳에서 막혔었는데,toggleContainer 와 toggleCircle 의 CSS적 관계였다. 두 요소는 한 묶음이 아니라 두개의 요소를 각각 배치하여 엎어놓은 형태였는데, 이 위치를 잡는것이 어려웠다. 부모요소는 position: relative, 자식요소는 position: absolute 를 주어서 작업하는데 작업화면(맥북)에서 위치를 잡아놓고 데스크탑화면으로 보면 브라우저가 늘어나면서 그 위치들도 늘어나는것이었다. 브라우저의 크기에따라 그 비율이 달라지면서 위치도 옮겨가는것 같던데, 아마 부모요소에서는 margin: auto로 센터를 잡아놓고 자식요소에서 수치를 맞춰가며 위치를 잡다보니 그렇게 된게 아닌가 싶다. 그래서 다시 부모요소와 자식요소의 위치를 같은 방식으로 맞춰봤더니 동일하게 위치했다.

### Deeper
먼저 토글의 특성을 생각해볼 필요가 있다, 토글은 클릭할때마다 그 상태가 변화하며 보이는 형태도 바뀌는 버튼인데, 그렇다면 우리는 토글의 변화하는 상태를 가져야할 필요가 있다.
useState 로 토글의 on/off 상태를 추가한다. 이 값은 boolean 형태로 이루어질것이다. 그리고 이 상태를 계속해서 on, off 로 변환시킬 수 있는 함수를 만들어야 한다, 계속해서 바뀌는 현재상태에 반대되는 상태를 제공해야 하기때문에 상태를 변화시키는 setToggleOn 에는 제한적인 true 를 전달하는것이 아니라 현재상태 !isToggleOn 을 전달함으로써 현재상태의 반대값을 전달할 수 있다.

이렇게 기본세팅이 완료되고, 이 변화하는 상태를 시각적으로 보여질 수 있는 UI를 제작한다.
토글버튼의 구조는 버튼을 감싸고 있는 background 와 움직임을 가지고 있는 버튼이 있다.
버튼이 좌우로 이동하며 on과 off를 표현한다. on 이 됬을경우 background 의 컬러가 바뀌면서 변화를 인지하게 할 수 있다. 먼저 background를 제작한다. 이 요소는 위치는 고정되어 있지만 컬러가 변하게 된다. 그렇기때문에 상태에 변화에 따라 컬러가 변할 수 있어야 한다, 나는 그것을 className을 활용하여 변화를 주었다. className에도 삼항연산자 즉, 조건문을 사용할 수 있다. 이것을 이용하여 on 일때의 className과 off 일때의 className을 설정해두고, 해당 상태에 맞게 CSS를 디자인해준다면 변화를 확인할 수 있다. toggleCotainer 를 기본 name으로 설정하고 그 후에 삼항연산자를 이용하여 상태가 on 일경우 뒤에 checked 라는 text를 추가하고, 그렇지 않다면 (off라면) 빈문자열을 추가해서 아무변화가 없게 하는것이다. 이렇게 되면 상태가 바뀔때마다 toggleContainer / toggleContainer checked 로 변화할 수 있게 되었다.

이 container가 품고있는 버튼 또한 같은방식으로 구현한다. 대신 이 버튼은 컬러가 변하진 않고 위치가 이동함으로 위치를 이동하게 하는 CSS를 구현해야 한다.

그리고 마지막으로 토글의 상태가 변화하였다는 메세지를 하단에 자리시키고, 이 역시 삼항연산자를 이용하여 isToogleOn 의 상태에 따라 메세지를 다르게 보여주게 했다.

<br />
<br />

![](https://user-images.githubusercontent.com/79869058/152924802-9aaa880f-1451-4ceb-a474-e0bcc5b01719.gif)


## 2. Modal

### 구현방법
버튼을 클릭했을때 기존 화면 위로 새로운 레이어가 생성되는 개념이기때문에 높이(z-index)의 요소가 필요하다. 이 또한 버튼을 클릭했을경우 / 안했을경우 의 상태가 나뉘어지기 때문에 해당 상태들을 이용하여 새로운 레이어를 보여주었다가 안보여주었다가 하는 동작을 수행하게 하면 될것이다.

### Error Handling Log
기존에 다른 프로젝트에서도 자주 만들던 Component라 해당 과제에선 구현하는데 어려움은 없었다. 

### Deeper
버튼을 하나만들어준다. 그리고 이 버튼에 상태를 부여한다. 상태는 boolean 값을 가지고, 한번 클릭할때마다 false 와 true가 계속해서 바뀌게 할 수 있는 함수를 생성하여 버튼 컴포넌트에 onClick 이벤트로 추가해준다. 정상적으로 클릭이 작동하는것을 확인하면, on의 상태일경우 생성될 새로운 레이어 창을 만들어야한다. 새로운 레이어창은 기존의 화면 위에 나타나는 느낌으로 만들어져야 하기에 z-index를 이용하여 레벨을 올려줌으로써 기존 레이어 상단으로 위치할 수 있게 그래서 겹쳐질 수 있게 한다.background 에서부터 경계를 만들어준다면 더 확실하게 느껴질 수 있다. background color 를 옅은 회색조의 컬러로 만들고, 전체화면을 덮을 수 있게 CSS를 조작해준다. 그 다음 레이어창을 만드는데, 이 부분은 어렵지 않다. 같은 레벨에서 흰색배경의 레이어창을 만들어주고, 레이어를 끄고 다시 버튼이 보이는 화면으로 돌아가게 할 수 있는 close 버튼과, 레이어가 성공적으로 생성됬다는 간단한 메세지를 레이어창에 추가한다. 이 close 버튼에 추가되는 이벤트 핸들러는 초반 버튼을 클릭할때 사용했던 이벤트핸들러를 사용하면 된다. 이 역시 on 에서 off로 이동해야하는것이기 때문에 굳이 다른 함수를 만들어 사용할 필요는 없기때문, 현재 구현된 상태는 close 버튼을 클릭했을때만 닫히게 할 수 있지만, 이벤트 핸들러가 들어가는 위치에 따라 background 나 레이어창을 직접 클릭해도 창이 닫히게 할 수 있다. 

<br />
<br />

![](https://user-images.githubusercontent.com/79869058/152925114-11867ebb-1a3d-4dff-96ea-69beaf13bf7c.gif)


## 3. Tab

### 구현방법
예시로 주어진 세가지의 탭메뉴를 배열에 묶인 객체로 만들어 놓고, 그 인덱스 순서를 활용한다. 클릭한 탭의 인덱스 순서를 상태로 가지고 있고, 그 상태를 이용하여 CSS에 변화를 주고, 텍스트를 출력하면 무리없이 구현할 수 있다. 개수가 있기때문에 일일이 구현하기 보다는 연속적으로 출력할 수 있는 고차함수를 이용해도 좋다. 

### Error Handling Log
처음에는 menuArr에 두가지의 값을 넣을 생각을 못하고 상태의 변화에 따라 name을 바꾸려고 했다가 뭔가 굉장히 쓸데없이 손이 많이가는 코드가 되어서 content 키를 추가하였더니 훨씬 편해졌다.

### Deeper
과제 예시를 보면 세가지의 탭 메뉴가 구성되어있고, 해당 탭을 클릭하면 탭 하단에 몇번째 탭이 클릭되었는지를 나타내는 텍스트를 간단하게 표현하는 방식인데, 그렇다면 이 두가지의 값을 가지고있는 객체를 총 세가지로 만들어서 묶어놓은 배열을 하나 만들어 놔야할것이다. 이 배열을 이용하여 탭을 만들텐데, 이 배열을 이용하기 위해서는 배열의 인덱스를 상태로 가지고있어야 한다. 그렇기때문에 useState를 만들고, 그 초기값을 0번째 인덱스인 0으로 만들어 놓는다. 그리고 우리가 해당 인덱스를 클릭할때마다 그 인덱스에 CSS적 변화를 주어야 하므로, 선택된 인덱스를 인식할 수 있는 함수를 만들어준다. 상태값을 변경하는 setIsClicTab에 클릭한 index를 인자로 넣어 현재 클릭된 인덱스의 상태값을 변화시킬 수 있다. 그럼 이 함수를 가지고 배열을 훑어야 하는데, 세가지라서 하나하나 해도 크게 문제는 없지만, 이 요소가 더 많았을때를 가정하며 고차함수 map을 이용해서 진행을 해본다.

map에는 해당 배열의 요소를 확인하는 el과, 배열의 인덱스를 확인하는 index를 추가하고, 클릭한 인덱스를 isClickTab으로 만들어 해당 상태일경우에만 className을 삼항연산자로 나누어 CSS를 조금 특별하게 만들어 선택이 된것처럼 표현을 하고, 나머지 두개의 요소는 비활성화 된 것처럼 표현을 한다.

그리고 마지막으로 탭하단에 menuArr의 현재 인덱스의 content 를 출력함으로써 마무리를 한다.

<br />
<br />

![](https://user-images.githubusercontent.com/79869058/152925145-3636586c-1e62-4411-8362-2ebe27f2ec73.gif)


## 4. Tag

### 구현방법
작성한 태그가 들어갈 배열을 만들고, 이 배열을 이용해야 한다. 일단 기능은 추가와 제거가 있다. 추가는 내가 작성한 text를 추가할 수 있어야하고, 제거는 태그 우측에 있는 close 버튼을 클릭하면 태그가 삭제되어야 한다. 추가의 경우에는 태그의 맨 우측순서로 쌓여가지만, 제거는 순서에 상관없이 삭제될 수 있어야하기에 이 점을 참고해야 한다. 이 두가지만 생각해서 작성을 해볼 수 있다.

### Error Handling Log
태그를 추가했을때 추가된 태그들을 정상적으로 삭제가 됬지만, 기존에 추가해두었던 두가지의 태그는 왜인지 삭제가 되지 않았다. 핸들러의 문제인지, 상태의 문제인지 계속 수정했다 지웠다 해봤지만 도무지 해결이 되지 않다가, 태그의 문제인것을 알아냈다. div를 사용했는데, span을 사용하니 정상적으로 삭제가 되었다. 아직까지 어떠한 차이인지는 모르겠다. li와 관련이 있는걸까..?

### Deeper
이 태그가 들어가는 input창을 하나의 배열이라고 생각하자, 예시에는 두개의 태그가 들어가있으니 초기 배열에 두개의 요소를 넣어놓는다. 그리고 이 배열에 요소를 추가하거나, 제거할수만 있으면 반은 성공한것이다. 일단 추가를 보면, input창에서 onKeyUp 이벤트로 내가 작성한 텍스트가 event로 전달이 될것이다. 그렇다면 그 event를 가지고 조건문을 하나 만들어줄텐데, 당연히 빈 문자열이라면 굳이 추가를 하지 않아도 되기때문에 그냥 리턴을 해주고, 그렇지 않고 문자열에 어떠한 텍슽트가 추가가 됬다고 한다면 해당 value를 배열의 끝에 추가하게 해주는 메서드 concat을 이용하여 현재 배열의 값을 담고있는 상태를 변화시키는 setIsTags에 추가함으로써 배열 끝에 내가 적은 value를 추가할 수 있게 되었다. 그리고 추가를 한 후 내가 적은 텍스트는 빈 문자열로 다시 초기화가 되야 하므로 event.target.value = "" 를 마지막에 추가해준다.

태그 제거의 방법은 fiter 메서드를 이용한다. 태그에, 그러니까 배열에 들어있는 요소들을 보고 내가 close 버튼을 클릭한 인덱스를 기억하여 이 인덱스를 삭제하는 indexToRemov 를 사용하여 해당 인덱스를 제거한다. 이것은 배열의 순서와 관계없이 삭제가 가능하다.

<br />
<br />

![](https://user-images.githubusercontent.com/79869058/152925156-0b09165c-ce36-4af4-928e-4e817de9e296.gif)


## 5. AutoComplete

### 구현방법
내가 작성한 텍스트가 이 기능이 가지고 있는 미리 저장된 요소들 중 동일한 요소를 가지고 있다면 출력해줘야 하는것이기 때문에, 일단 같은 요소가 있는지를 판단해주는 상태값이 하나 필요하고, 내가 input 창에 작성하는 값을 가질 상태값이 필요하고, 그리고 비교할 요소가 들어있는 미리 생성된 배열중 내가 작성한 input값과 동일한 요소만을 가지고 있는 인덱스를 뽑아줄 상태도 필요하다. 이 세가지의 기능을 이용하여 자동완성기능을 만들 수 있을것이다.

### Error Handling Log
초반 제작시, 작성한 text를 비교할 수 있는 isAutoComplete 배열에 그냥 입력된 event.target.value 로 비교를 하려고 했더니 오류가 생겼었다. 왜냐하면 배열의 상태에 텍스트형식을 넣으려고 하니 오류가 생겼던것, fiter 함수를 이용해서 해당 value를 배열의 형태로 받아와서 변화를 주어야 정상적으로 작동하였다.

### Deeper
자동완성을 가능하게 해줄 기본단어 몇가지를 가지고있는 배열을 먼저 만들어 준다. 이것이 자동완성단어들이 들어있는 배열이다. 상태를 세가지정도 만들텐데, 첫번째는 내가 작성한 텍스트가 자동완성단어들 중에 있는지를 판별하는 상태값이고, 두번째는 내가 input창에 작성한 값을 가지는 상태값이다. 그리고 세번째는 자동완성단어들이 들어있는 배열안에서 내가 작성한 텍스트와 동일한 요소가 들어있는것만 걸러서 보여줄 수 있는 상태값이다. 이렇게 준비를 마치면 각각의 기능을 할 수 있는 함수를 만들어줘야 한다. 첫번째로 내가 input창에 텍스트를 입력하면 자동완성기능을 켜고, 만약 적은 텍스트중에 자동완성단어 가 있다면 그 단어들을 다시 필터링하여 자동완성 블록에 보여줄 수 있는 기능이 필요하다. 그리고 useEffect 를 이용하여 실시간으로 input창이 비어있다면 자동완성기능을 끄는 조건식을 만들어준다. 그리고 작성한 텍스트를 한꺼번에 삭제할 수 있는 기능도 만든다, 간단하다. setInputValue에 빈문자열을 넣어주면 된다.

<br />
<br />

![](https://user-images.githubusercontent.com/79869058/152925202-932012cd-84d8-4391-9e31-bec6e5aa03e0.gif)


## 6. ClickToEdit

### 구현방법
초기값을 가지고있는 input창을 클릭해서 다시 새로운 값을 추가하면 작성이 이루어짐과 동시에 해당 value 를 출력할 수 있는 기능을 넣어주면 완성이다. 크게 어렵지 않다.

### Error Handling Log
해당 기능도 사이드프로젝트 개인정보 변경기능으로 많이 연습했던 기능이라 어렵지 않게 구현했다.

### Deeper
이 기능에는 함수가 크게 두가지가 들어간다. 왜냐하면 들어온 value값을 표현하는 함수 하나와, 해당 함수를 수정할 수 있는 함수 하나가 필요하기 때문이다, 물론 합쳐서 할 수 는 있지만, 나누어서 하는것이 더 깔끔하다고 판단했다. 일단 기본적으로 해당값을 출력하여 보여주는 함수자체는 크게 복잡하지 않고 단조롭다. useState로 초기값을 가지고 있는 상태값을 이용하여 위치정도만 조정하여 화면에 나타내 놓으면 되고, 해당 value값을 포함하고 있는 컴포넌트에 수정기능을 가질 함수를 추가해 놓는다. 그리고 이제 수정기능을 만들텐데 useRef 를 활용해야 한다. useRef 란 특정 DOM 요소를 선택할 수 있는 기능을 가지고 있어서 이 기능을 이용해 해당 요소를 수정가능하게 할것이다. 그리고 수정기능을 껏다 킬 수 있는 상태값도 하나 만들어주고, 새로운 값이 들어갈 상태값 도 가지고 있어준다. 수정할 value 를 클릭하면 수정기능이 활성화되고 해당 value를 품고있는 input 창으로 변하게 한다. 그리고 value를 수정하고 input창 밖을 클릭하면 바꾼 value가 현재값이 된다. 그리고 하단에는 값이 변할때마다 해당 값을 출력해주는 텍스트를 간단하게 추가해주면 끝이다.

<br />
<br />
